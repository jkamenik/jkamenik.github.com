---
layout: post
title: "Software Hazard Pay"
date: 2011-09-08
comments: false
categories:
 - rant
 - opinion
---

<div class='post'>
The military has a concept of "hazard pay" which is extra money because you are placing your life on the line. &nbsp;Software has something similar, though certainly not as permanent, where you are putting your socioeconomic well being on the line.<br /><br />The following is a list of things that I think are software hazards that should require more pay.<br /><br /><span style="font-size: x-large;">Dress-code&nbsp;Policy</span><br />A policy is an explicit rule created to cover an&nbsp;anomaly. &nbsp;And when the anomaly is repaired the policy remains. &nbsp;Dress-code policies ("dress atire shall be no less then business&nbsp;casual") like social-conduct policies ("you shall report yourself in a&nbsp;professional&nbsp;manner") are specifically vague, as to leave management&nbsp;leeway so that enforcement is&nbsp;discretionary.<br /><br />I am against these type of policys because they setup a&nbsp;confrontational&nbsp;attitude between&nbsp;management&nbsp;and workers. &nbsp;I personally do not know of any professional (sorry, but waiters and waitresses don't count) that has been fired because of the enforcement of a dress-code policy, so I have to question the merits of&nbsp;explicitly&nbsp;stating one.<br /><br />Look at truly innovative technology companies and you will notice one thing lacking: a dress-code policy.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Software IT</span><br />Software engineers, that are good, are tinkerers. &nbsp;We have broken more then a few computers in our day, and almost always figure out why and fix it. &nbsp;The job of an IT department is to prevent employees from tinkering with computers, because it costs the company valuable effort.<br /><br />These two departments can only co-exist as peers. &nbsp;In general if IT provides API to standard services like Email then software developers will never have to bother IT with questions. &nbsp;After all software developers are usually overqualified IT.<br /><br />If the company codes for the Linux platform, but software developers are required to use windows machines this is a sign of an imbalance between Software and IT.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">No SVC</span><br />Every programmer that has been out of college for more then a semester knows about Source Versioning Control systems. &nbsp;There isn't even a debate anymore, they are essential for programming. &nbsp;A company without at least some type of SVC is scary.<br /><br />If you know and understand GIT then you can solve this problem for the company, but if the other engineers are not familiar with such system there is going to be strong, and often emotional, opposition. &nbsp;Not something a professional should have to deal with.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Commercial SVC</span><br />There is no commercial SVC software out there that has the usefulness that GIT does. &nbsp;There are a lot that fill in for the lack of usefulness by adding bloat, like user management. &nbsp;Commercial SVCs are always sold to detached CTOs by sales guys that hide its destructive nature.<br /><br />Only a detached CTO would buy software without first letting the developers review it for usefulness. &nbsp;I do honestly think commercial SVC systems are destructive because they always designed for an audience that is not software developers. &nbsp;At best this means that the developers adapt, but usually it means that adding wildly complicated procedures to deal with the lack of a good flow.<br /><br />VSS is a great example of this failure. &nbsp;It only supported file locking, because it is easiest to implement. &nbsp;It also could not deal with merge conflicts, so external tools has to be purchased to deal with that. &nbsp;Also, if files were locked the nightly internal cleaning routine would not run so you couldn't keep files locked overnight. &nbsp;It didn't support branches (as we know them today) so everyone worked on the same set of files, and locked each other out all the time. &nbsp;It was hell!<br /><br /><span class="Apple-style-span" style="font-size: x-large;">No CI</span><br />This is the first thing I do before any code is written. &nbsp;I create an empty repo, put an a rake/make/cake file that simply has one step "ci" and attach that to a CI server. &nbsp;As soon as we know the details of the language, testing framework, coverage metrics, etc... I adjust "make ci" to do those things.<br /><br />It is so simple to setup that if it isn't there then it erodes my confidence in the entire project. &nbsp;Tests are the only reliable communicator of assumptions, and not having a system that actively enforces those assumptions will cause greater complications later.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Required IDE</span><br />Detached management love IDE's, because they speak in a language that managers understand: GUI. &nbsp;Sometime they are useful and sometimes they are not. &nbsp;And most of the time they bloated, slow, and expensive.<br /><br />Any editor that can shell out is an IDE. &nbsp;So if using a specific IDE is required then someone is forcing their bad ideas on you. &nbsp;The emacs vs. vi debate still rages because they are as powerful (in cases more so) then what we think of as IDEs (xcode, eclipse, etc...), but they both are and neither requires a specific "project" file to manage a project.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Cowboys and "Heroes"</span><br />Cowboy coders prefer to work alone, often thinking themselves and their code superior to other developers. &nbsp;If there are not code reviews, it is usually because of adamant opposition from these guys. &nbsp;Even if they lose the code review fight they will fight be exempt from code reviews themselves.<br /><br />All they do is hack some stuff together without thought of quality or&nbsp;maintainability&nbsp;and call it done. &nbsp;They are dangerous, and the quality of the system will suffer as the project gets too complicated to fit entirely within their own heads.<br /><br />A "hero" is a very loud cowboy. &nbsp;They are the software&nbsp;equivalent&nbsp;of "yes" men. &nbsp;They tell management what they want to hear, and often gain position greater then their experience and expertise. &nbsp;Unfortunately they almost always spell doom to a project in one way or another. &nbsp;Sometimes it is outright fail to produce a workable product, and sometimes it is a mass&nbsp;exodus&nbsp;of skilled workers.<br /><br />Both cowboys and "heroes" have a habit of getting&nbsp;entrenched&nbsp;and are very hard to unseat, but the project will not survive them.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Coding Silos</span><br />For reason beyond my understanding managers usually frown upon agile approaches like pair programming. &nbsp;It is seen as wasting company time and tantamount to theft. &nbsp;Instead they would prefer programmers to "just do their job" which involves writing code and not much else.<br /><br />A vertical silo is where you are expected to do everything from the GUI to the database layer. &nbsp;On small projects this is expected and even wanted. &nbsp;But rarely (unless you doing it on your own time) will is a progressional project be that small. &nbsp;When a person holds the entire stack in their heads then the apparent usefulness of MVC (or similar patterns) breaks down. &nbsp;This later leads to scaling problems.<br /><br />A horizontal silo is when there are many projects for the company and you maintain the same role on ALL of them. &nbsp;A major problem is in solving the wrong problems. &nbsp;For example: you are the DBA for all apps in the company. &nbsp;You have a very expensive Oracle DB and know it well, and have a bunch of homegrown&nbsp;management&nbsp;scripts. &nbsp;Therefore all web apps run on the same Oracle DB server because it is quicker and easier for you, and now there are two single points of failure (you and DB). &nbsp;Sqlite would have been good enough, but that isn't how specialized people think. &nbsp;"When all you have a hammer all problems look like nails" - Barry Gruenberg.<br /><br />Another problem with horizontal silos is a stagnating. &nbsp;For example: a junior engineer wants to use a new distributed key/value store like Cassandra or CouchDB. &nbsp;You argue with management that a simple key/value table in the already sharded Oracle DB would be good enough and would save the company money in both hardware and effort. &nbsp;You might be right, or you might be wrong; but you are&nbsp;guaranteed&nbsp;not be to&nbsp;exposed&nbsp;to a different way of thinking. &nbsp;In the long simple acts complacency and stagnation undo large projects.<br /><br />The only sustainable solution is a cross functional team, where everyone has areas of strength and weakness but they work on the system as a whole.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Value Based Estimates</span><br />At market driven company it is not uncommon to see estimates done by those not qualified to do them (management). &nbsp;A marketing department will usually attach a proposed value of a given feature, or product. &nbsp;This automatically skews the estimate by placing an upper bound (the value minus require profit).<br /><br />If the company communicates well then realistic estimates are given by developers, and if those estimates are higher then the projected value then the feature or product is not invested in. &nbsp;In marketing driven the realistic estimate are not done or are ignored and the project moves forward with the value estimate.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Detached Management</span><br />Much of what has already been stated come from the same source: detached management. &nbsp;A detached manager will often blame the developers for failures in software and procedures he/she is forcing on them. &nbsp;"A carpenter doesn't blame his tools" is a common excuse. &nbsp;If a developer is lazy and as no interest in keeping up with the industry it is a valid excuse, but &nbsp;more often the manager just doesn't want to hear that they did not fully think though the problem before forcing a solution.<br /><br />Early in the game this looks like a manager that doesn't show up to scrum calls because they are too busy.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Overstaffing</span><br />One of the easiest ways to make a budget look needed is to hire a bunch of staff. &nbsp;If there is an influx of new hires, especially if they appear unqualified or under qualified then it is possibly for budgetary reasons.<br /><br />The unfortunate side effect of overstaffing (even if the staff is qualified) is laziness. &nbsp;More staff equals more cooks in the same amount of space, which in turn equals more confusion and less efficiency. This lack of efficiency leads to an imbalance of responsibilities and therefore some will be overworked and other underworked. &nbsp;Underworked employees become complacent, and overworked ones become annoyed and will work less. &nbsp;This drives overall productivity down.<br /><br />Adding staff at any stage of a project makes the project take longer and that will continue to be true until we learn to download and upload expertise.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Market Driven or Marketing Driven company</span><br />Companies driven by a Marketing Department (how ever good) are reactive companies. &nbsp;There is no vision of how things should, or why they should be that way. &nbsp;It takes a visionary to reduce a companies offering, and instead focus on quality. &nbsp;Marketing departments do not do this, they always add more.<br /><br />In fact, there is a certain critical mass in which a marketing department exists to exist. &nbsp;This is the point at which the marketing budget becomes as big (or bigger) then the R&amp;D and Engineering departments, so they can convince users of the usefulness of the product (which probably isn't).<br /><br /><span class="Apple-style-span" style="font-size: x-large;">"Putting out fires"</span><br />Anytime I hear "putting out fires" I know the project is doomed. &nbsp;Things probably got this way gradually over time, but at this point there is too much technical debt to warrant moving forward. &nbsp;Projects that cannot move forward die.<br /><br />The only way to prevent this situation is to head it off early by dealing with heroes before they cause trouble and keeping marketing in check.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">"Continuous Work"</span><br />Anytime I hear someone from a company (usually marketing) mention continuous or unending work I get nervous. &nbsp;I understand that it is an attempt to make it seem like the job is on going and therefore safe, but I am not a factory worker. &nbsp;The stuff I work on should have a natural conclusion, and the knowledge I gained should then be used on another project.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">"Competitive Salary"</span><br />Anytime I hear "Competitive Salaray" I know three things: 1) its a lie, 2) they gear to recruiters, not requirements, 3) they under value employees. &nbsp;Huge red flags are raised.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Agile Lip-service</span><br />A lot of companies are flocking to Agile as an end all be all. &nbsp;But that is exactly what Agile is not. &nbsp;I have detailed in an <a href="http://randomsoftwareinklings.blogspot.com/2011/01/problems-with-agile-implementation.html">earlier post</a>&nbsp;a number of bad implementation and companies that think Agile is a silver bullet are likely to make some or all of them.<br /><br /><br /></div>
