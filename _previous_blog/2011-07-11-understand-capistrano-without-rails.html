---
layout: post
title: "Understand Capistrano without rails"
date: 2011-07-11
comments: false
categories:
 - howto
 - Capistrano
---

<div class='post'>
I am working on a rails project and that rails project is distributed over several nodes in a cluster. &nbsp;However, each of those nodes is a standalone unit and the rails app is a small administrative frontend for that box only. &nbsp;For this reason the standard Capistrano deployment tasks will not work.<br /><br />Looking around I noticed a number of projects that were just deployment steps for other frameworks and stacks, but still required Capistrano. &nbsp;This got me thinking that maybe Capistrano is more then just a set of deployment steps. &nbsp;The wiki does not make this clear but there are three parts to&nbsp;Capistrano: 1) an engine to replicate (transactionally) commands on any number of servers, 2) a rake like DSL for defining tasks to perform on remote servers, and 3) a set of deployment recipes specifically tied to rails. &nbsp;The first two items are what I need and by not including the recipes I can do anything I want.<br /><br />Below is my understanding of how Capistrano<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Sample config/deploy.rb file</span><br />The below code is an example that will be reference throughout.<br /><br /><div class="code"><pre>role :servers, 'host1'<br />role :client, 'host2', 'host3'</pre><pre>role :client, 'host4', :special =&gt; true<br /><br />task :install, :roles =&gt; :servers do<br />  run "uname -a"<br />end<br /><br />task :test, :roles =&gt; :client do<br />  sudo 'echo TEST'<br />end<br /></pre><pre></pre><pre>test :special, :roles =&gt; :client, :only =&gt; {:special =&gt; true} do</pre><pre>sudo "echo SPECIAL"</pre><pre>end</pre></div><br /><span class="Apple-style-span" style="font-size: x-large;">Understanding Roles</span><br />Capistrano uses "roles" to list servers with similar behaviors. &nbsp;The default&nbsp;recipe uses roles like "web" and "db" and makes it seem like that they are in some way special. &nbsp;They really are not. &nbsp;The only way they are used is by the "roles" option when defining a task.<br /><br />When a task defines "roles" then it will only be called on the server that have that role (see sample). &nbsp;Additionally options can be added to the end of roles that act like flags that can later be used by tasks to filter. &nbsp;Armed with understanding we can easily create arbitrary roles for use in our deployment steps.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Understanding Tasks</span><br />Capistrano is a simplified rake like syntax. &nbsp;If you are familiar with rake there are few gotcha: 1) tasks cannot take input, and 2) tasks and namespaces cannot overlap. &nbsp;Both of these can be worked around however.<br /><br />Deployment tasks should never (NEVER) take user input. &nbsp;User input is a variable that cannot be repeated automatically. &nbsp;So armed with the knowledge that if you "need" user input in deployment then you are doing something wrong rework the system to not require user input and move on.<br /><br />There is only one special task name that I have found ":default". &nbsp;If you make a task ":default" then it will simply become the task that is run when the namespace is called. &nbsp;It also, takes itself out of the help list so there is no task "namespace:default".<br /><br /><span class="Apple-style-span" style="font-size: large;">Understand Flags</span><br />Task provide the options "except" and "only" that work on role flags. &nbsp;In the sample there is a task ":special" that will only run for hosts with the "client" role that also have the ":special" flag set to true. &nbsp;The included deployment recipe adds ":primary" to the ":db" role to indicate that it is the only server on which migrations should be run. &nbsp;I currently have no use for flags, but it is nice to understand their behavior.<br /><br /><span class="Apple-style-span" style="font-size: large;">Calling other tasks</span><br />In rake it is possible to say that a task depends on other tasks. &nbsp;In&nbsp;Capistrano&nbsp;it is not. &nbsp;This is not a problem since task is a wrapper around a method&nbsp;definition. &nbsp;Basically you can call a task in the current namespace by using its name like a method. &nbsp;And you can call methods in higher namespaces using "top".<br /><br /><div class="code"><pre>task :upload do<br />  puts "real upload"<br />end<br /><br />namespace :child do<br />  task :upload do<br />    puts "child upload"<br />  end<br /><br />  task :upload1 do<br />    top.upload<br />  end<br />end<br /><br />$ cap upload<br />real upload<br />$ cap child:upload<br />child upload<br />$ cap child:upload1<br />real upload<br /></pre></div><br /><span class="Apple-style-span" style="font-size: x-large;">Understanding Connections</span><br />In addition to being a DSL to define deployment tasks Capistrano is also an SSH connection manager. &nbsp;Using the "run" or "sudo" function Capistrano will execute that string at a shell on each remote machine in turn. &nbsp;The gotcha is that each call to "run" or "sudo" opens an entirely new connection. &nbsp;Therefore if several things need to be done at once use ";" or "&amp;&amp;" to chain commands in a single shell.<br /><br /><br /><div class="code"><pre>task :test do<br />  run "export TEST=foo &amp;&amp; echo $TEST"<br />  run "echo $TEST"<br />end<br /><br />$ with servers !test<br />** [out :: host1] foo<br />** [out :: host1] <br /></pre><pre></pre><pre></pre><pre>$ with client !test</pre><pre><span class="Apple-style-span" style="font-family: Times; white-space: normal;"><pre>** [out :: host2] foo</pre></span><span class="Apple-style-span" style="font-family: Times; white-space: normal;"><pre>** [out :: host3] foo</pre></span><span class="Apple-style-span" style="font-family: Times; white-space: normal;"><pre>** [out :: host4] foo</pre></span><span class="Apple-style-span" style="font-family: Times; white-space: normal;"><pre><span class="Apple-style-span" style="font-family: Times; white-space: normal;"><span class="Apple-style-span" style="font-family: Times; white-space: normal;"><pre>** [out :: host2] </pre></span><span class="Apple-style-span" style="font-family: Times; white-space: normal;"><pre>** [out :: host3] </pre></span><span class="Apple-style-span" style="font-family: Times; white-space: normal;"><pre>** [out :: host4] </pre><div></div></span></span></pre></span></pre></div><br />In the above example the ENV variable "TEST" is set to foo, but since the second "run" gets a new shell the ENV is reset. &nbsp;Also, in the second example it is clear that each "run" is executed on every server before it moves onto the next server.</div>
