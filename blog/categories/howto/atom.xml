<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: howto | Random Software Inklings]]></title>
  <link href="http://jkamenik.github.com/blog/categories/howto/atom.xml" rel="self"/>
  <link href="http://jkamenik.github.com/"/>
  <updated>2014-09-21T21:55:24-04:00</updated>
  <id>http://jkamenik.github.com/</id>
  <author>
    <name><![CDATA[John T. Kamenik]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[rake publish]]></title>
    <link href="http://jkamenik.github.com/blog/2014/06/23/rake-publish/"/>
    <updated>2014-06-23T08:29:00-04:00</updated>
    <id>http://jkamenik.github.com/blog/2014/06/23/rake-publish</id>
    <content type="html"><![CDATA[<p>Octoblog (the engine behind this blog) uses <a href="http://jekyllrb.com/">Jekyll</a>.  As such, it also supports the <code>publish</code> flag.  I a previous post I detailed how I added this feature back to Octopress.  Here I will show you a little rake task to easily publish an unpublished post.</p>

<!-- more -->


<h2>Requirements</h2>

<p>For a post to be published I wanted a few things to happen:</p>

<ol>
<li><code>published: true</code> was set in the YAML front-matter</li>
<li><code>date: &lt;todays date&gt;</code> was set in the YAML front-matter</li>
<li>The file was moved to today.</li>
</ol>


<p>Here is what I came up with.</p>

<p>```ruby Rakefile
desc "Publishes an unpublished entry by changing its name, updating its internal timestamp, and setting published: true"
task :publish, :pattern do |t, args|
  require 'tempfile'
  require 'fileutils'</p>

<p>  files = Dir[File.join(source_dir,posts_dir,args[:pattern])]
  raise "No files found matching pattern" if files.size == 0
  raise "Too many files match pattern" if files.size > 1</p>

<p>  name_time = Time.now.strftime('%Y-%m-%d')
  file_time = Time.now.strftime('%Y-%m-%d %H:%M')</p>

<p>  file = files.first
  name = File.basename file
  new_name = name.gsub(/\d+-\d+-\d+/,name_time)
  w        = Tempfile.new('publish')</p>

<p>  File.open file do |f|</p>

<pre><code>scan = false
f.readlines.each do |line|
  # limit scanning to the YAML front matter
  scan = !scan if line == "---\n"
  unless scan
    w.write line
    next
  end

  line.gsub!(/published.*/,"published: true")
  line.gsub!(/date.*/, "date: #{file_time}")

  w.write line
end
</code></pre>

<p>  end
  w.close</p>

<p>  FileUtils.rm file
  FileUtils.mv w.path, File.join(source_dir,posts_dir,new_name)
end
```</p>

<p>Line 6: I take a argument and get a list of files matching the pattern</p>

<p>Line 7 &amp; 8: I found it was too easy to screw up a pattern and publish too few or too many posts.  For that reason I am explicit about the failure.</p>

<p>Line 15: Calculates its name for today.</p>

<p>Line 16 &amp; 37: Generate a temp file to write to.  I found that bad things happened if you published a post that you wrote the same day.  Solution was to write to a temp file and then move the temp file later.</p>

<p>Line 19 &amp;&amp; 22: An inelegant solution to isolating scanning to only the YAML front-matter.</p>

<p>Line 28 &amp; 29: Update the YAML front-matter.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Query Language]]></title>
    <link href="http://jkamenik.github.com/blog/2014/06/22/google-query-language/"/>
    <updated>2014-06-22T11:19:00-04:00</updated>
    <id>http://jkamenik.github.com/blog/2014/06/22/google-query-language</id>
    <content type="html"><![CDATA[<p>A while back, my wife and I started keeping a budget.  We need something very easy that shows us where we are every moment.  Also, to ensure that it is not something we "forget" it must be something that we manually enter.</p>

<p>I created a Google Form in order to allow us to capture the receipts.  The form dumps into a Google Spreadsheet.  I then use a Pivot Table and the Google Query Lanauage to create a Chart.  In this post I will cover the entire process.</p>

<!-- more -->


<h2>Step 1: Create a form</h2>

<ol>
<li>Create a google form</li>
<li>Add the following fields

<ol>
<li>"Company" - text- required</li>
<li>"Date" - date - required (don't include time)</li>
<li>"Amount" - text - required (add a "number" validation)</li>
<li>"Category" - list - required.  We added the following

<ol>
<li>Other / Unknown</li>
<li>Baby Supplies</li>
<li>Car</li>
<li>Entertainment</li>
<li>Gas</li>
<li>Groceries</li>
<li>Home</li>
<li>Medical</li>
<li>Pet Supplies</li>
<li>Resturants / Fast Food</li>
</ol>
</li>
<li>"Comment" - paragraph</li>
</ol>
</li>
<li>Choose response destination

<ol>
<li>Choose a "New Spreadsheet"</li>
</ol>
</li>
<li>Send the form to yourself and anyone else that needs to enter receipts</li>
</ol>


<p>At this point you have a Form which submits to a Spreadsheet.  I recommend bookmarking the link in your smart-phone so that it is easy and quick to add receipts right after your purchases.</p>

<h2>Step 2: Pivot</h2>

<p>Form usually record into a sheet called "Form Responses" which I assume here.</p>

<ol>
<li>Select "Form Responses"</li>
<li>Select Data -> Pivot table report...

<ol>
<li>Rows - Add "Category"</li>
<li>Values - Add "Amount"</li>
</ol>
</li>
</ol>


<p>Now you should have a two column table.  On the left are the categories.  On the right is the sum of all the values of that category.</p>

<h2>Step 3: Google Query</h2>

<p>In order to chart the budget vs the actual spending we need to create another table.</p>

<ol>
<li>Insert a sheet named Budget.</li>
<li>Label the columns: Category, Budget, Actual, Query</li>
<li>Copy all the categories to column A</li>
<li>Add the budgeted amount to column B</li>
<li>Add the following to column C

<ol>
<li><code>=if(isna(C2), 0, C2)</code></li>
</ol>
</li>
<li>Add the following query to column D

<ol>
<li><code>=QUERY('Pivot Table'!A:B, "select B where A='"&amp;A2&amp;"'","")</code></li>
<li>"#N/A" means that are no receipts for the category and can safely be ignored.</li>
</ol>
</li>
<li>Copy and paste cell C2 and D2 to the rest of the cells in the column

<ol>
<li>Google will change the internal references (A2, and C2) to the correct cell name, so you don't have to.</li>
</ol>
</li>
</ol>


<p>The Google Query Language is defined <a href="https://developers.google.com/chart/interactive/docs/querylanguage">here</a>.  It is a good read to see all the power of this language, but I am only going to explain the parts that we need.</p>

<h3>Query</h3>

<p><code>QUERY</code> takes three arguments: range of values, query string, and optional headers.  I am going to explain them in reverse.</p>

<p>The headers are guessed if nothing is provided.  This would cause the query to take two cells, which is not the behavior I wanted.  By adding "" it removes the header.</p>

<p>The query string tells google what data we are selecting into the cell.  In our simple example it is a direct value select using a conditional.  This is because the column order may not be the same in both sheets.  "select B" means to choose the "B" from whatever rows match the query.  "where A='"&amp;A2&amp;"'" means to limit the rows returned to those where the value of cell A matches the value of A2 in this sheet.  The "&amp;" is the string concat operator.</p>

<p>The range of values tells Google what it is allowed to look at.  We use the 'Sheet'!Col:Col form in order to select data from another sheet.  We only provide the columns A and B because we want to look at all rows.</p>

<h3>ISNA</h3>

<p>Charts cannot deal with non-number columns.  Since the query can produce a non-number output (#N/A) we need to add an additional level of processing.</p>

<p><code>isna</code> takes a cell and returns if that cell is #N/A.</p>

<p><code>if</code> take a boolean, a true value, and a false value.  If the first argument is true then the true value is returned.  If the first argument is false then the false value is returned.</p>

<h2>Step 4: Chart</h2>

<p>Charts can only take numbers and they can only accept contiguous cells.  A, B, and C are the columns that we want to chart.</p>

<ol>
<li>Insert -> Chart</li>
<li>Data range: Budget!A1:C14</li>
<li>Use row 1 as headers</li>
<li>Chart type: Bar chart</li>
<li>Add a chart title</li>
</ol>


<h2>Step 5: Publish</h2>

<p>The point of this document is to know where your money is going quickly.  In order to make it easy publish the document.  This will make google convert the document into a HTML version which is easily viewed in your smart phone.  The chart will even be convert to an image.</p>

<ol>
<li>File -> Publish to the web...</li>
<li>Check "Automatically republish when changes are made"</li>
<li>Copy the link</li>
<li>Send to link to anyone that needs to be kept informed about the budget</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crafty Timer]]></title>
    <link href="http://jkamenik.github.com/blog/2014/02/24/crafty-timer/"/>
    <updated>2014-02-24T13:28:00-05:00</updated>
    <id>http://jkamenik.github.com/blog/2014/02/24/crafty-timer</id>
    <content type="html"><![CDATA[<p>Crafty JS is a game engine written in Javascript.  Like many game engines there is a main event loop that drives everything.  This is actually a great thing, unless you are trying to use timers.</p>

<p>Javascript is single threaded but asynchronous.  This means there is no way to "sleep" the main loop.  Instead there is a <code>setTimeout</code> function which takes a callback that is called after the timer has expired.  In most JS programs having one or more timers setup via <code>setTimeout</code> isn't much of an issue.</p>

<p>In Crafty there is already a main event loop that actually performs the same function and it better fits the separation of background and rendering responsibilities.  Remember that in a game you will have hundreds or thousands of background calculation per second but only 40 to 60 rendering calculations.</p>

<p>With that in mind I created two components: a Timer which does everything in the background, and TimePrinter which is a timer and rerenders the current seconds until the timer expires.</p>

<!-- more -->


<h2>Timer</h2>

<p>```coffeescript timer.coffee
Crafty.c('Timer',{
  <em>stopFunc:    null,
  </em>expireTime:  null,
  _secondsLeft: null,</p>

<p>  start: -></p>

<pre><code>return if this._stopFunc
return if this._calculateTime &lt;= 0

self = this
this._stopFunc = Crafty.bind('EnterFrame', -&gt;
  # a proxy callback which sets the "this"
  self._calculateTime()
)
this
</code></pre>

<p>  stop: -></p>

<pre><code>return unless this._stopFunc
Crafty.unbind('EnterFrame', this._stopFunc)
this._stopFunc = null
this
</code></pre>

<p>  expiresIn: (seconds, autoStart = false)-></p>

<pre><code>this._expireTime = Date.now() + (seconds * 1000)
this.start() if autoStart
this
</code></pre>

<p>  addSeconds: (seconds, autoStart = false)-></p>

<pre><code>this._expireTime = Date.now() if this._secondsLeft &lt;= 0
this._expireTime += (seconds * 1000)
this.start() if autoStart
this
</code></pre>

<p>  _calculateTime: (event)-></p>

<pre><code>now  = Date.now()
left = this._expireTime - now
this._secondsLeft = Math.floor(left / 1000)

this.stop() if this._secondsLeft &lt;= 0
this._secondsLeft
</code></pre>

<p>})
```</p>

<p><code>start</code> starts the timer.  It binds to the "EnterFrame" event and sets up a proxy callback to ensure the "this" variable is maintained during the callback.</p>

<p><code>stop</code> remotes the "EnterFrame" callback thereby detacting it from the timer loop.</p>

<p><code>expiresIn</code> sets up a number of seconds to expire the timer in.  There is an optional second paramter to start the timer loop.</p>

<p><code>addSeconds</code> adds seconds to the existing timer, making it take longer to expire.  If the timer has expired then it behaves like <code>expiresIn</code></p>

<p><code>_calculateTime</code> is the work horse.  It calculates the real time and compares it to the expire time and returns the number of seconds until it expires.  If the current time is greater or equal to the expire time then the timer is considered expired and is stopped.  Stopping the timer removes any useless calculations, speeding up the overall game.</p>

<h2>Time Printer</h2>

<p>In order to separate concerns I created a separate component to print the number of seconds until the timer expires.  By separating things out I can have a general purpose timer which is displayed many different ways.</p>

<p>This class simply shows the number of seconds left as a string.</p>

<p>```coffeescript time_printer.js
Crafty.c('TimePrinter',{
  init: -></p>

<pre><code>this.requires '2D, DOM, Text, Timer'
this.attr({
  x: 100,
  y: 100,
  w: 200
})
self = this
this.bind('RenderScene',-&gt;
  self.render()
)
</code></pre>

<p>  render: -></p>

<pre><code>this.text ''+this._secondsLeft+' seconds'
</code></pre>

<p>})
```</p>

<p><code>init</code> requires the DOM, 2D, and Text components so that I can render text.  It also requires Timer so that it behaves like a Timer.  It also binds to the "RenderScene" event, which just rendering thread.</p>

<p><code>render</code> is the call back called when it is time to render the entity.</p>

<h2>Usage</h2>

<p>A simple usage might look something like this:</p>

<p><code>coffeescript scene/loading.coffee
Crafty.scene('Loading',-&gt;
  printer = Crafty.e("TimePrinter")
  printer.expiresIn 10, true
)
</code></p>

<p>```html timer.html
<html>
<head></p>

<pre><code>&lt;script src="lib/crafty.js"&gt;&lt;/script&gt;
&lt;script src="src/components/timer.js"&gt;&lt;/script&gt;
&lt;script src="src/components/time_printer.js"&gt;&lt;/script&gt;
&lt;script src="src/scenes/loading.js"&gt;&lt;/script&gt;
&lt;script&gt;
  window.addEventListener('load',-&gt;
    Crafty.init()

    Crafty.scene('Loading')
  )
&lt;/script&gt;
&lt;style&gt;
    body { 
        padding: 0;
        margin:  0;
    }
&lt;/style&gt;
</code></pre>

<p></head>
<body></body>
</html>
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drafts]]></title>
    <link href="http://jkamenik.github.com/blog/2014/01/21/drafts/"/>
    <updated>2014-01-21T11:38:00-05:00</updated>
    <id>http://jkamenik.github.com/blog/2014/01/21/drafts</id>
    <content type="html"><![CDATA[<p>Jekyll supports unpublished posts, but Octopress does not make it clear.  This is how I fixed that for my own blog.</p>

<!-- more -->


<p>Octopress actually does support "published: false" in the front matter.  And because it based on Jekyll it means that those posts will be available in "preview" but will be ignored when the site is generated/published.</p>

<p>My main care is that I know what I can do with a post in 3 to 4 months.  So I added the the published flag to the generated frontmatter of every new post.</p>

<p>```ruby Rakefile</p>

<h1>around line 93, for me</h1>

<p>task :new_post, :title do |t, args|
  # code omitted
  open(filename, 'w') do |post|</p>

<pre><code>post.puts "---"
post.puts "layout: post"
post.puts "title: \"#{title.gsub(/&amp;/,'&amp;amp;')}\""
post.puts "date: #{Time.now.strftime('%Y-%m-%d %H:%M')}"
post.puts "comments: true"
post.puts "toc: false"
# add published flag to the template
post.puts "published: false"
post.puts "categories: "
post.puts "  - cat1"
post.puts "---"
post.puts
post.puts "Summary"
post.puts
post.puts "&lt;!-- more --&gt;"
post.puts
post.puts "Post text"
</code></pre>

<p>  end
end
```</p>

<p>I also had to update <code>rake push</code> to regenerate the full site before deployment.  This is because preview works on the same directly that is copied to production.  And since you can preview unpublished posts they will be visible in production, unless you run <code>rake generate</code> first.</p>

<p>```ruby Rakefile</p>

<h1>around line 254</h1>

<p>multitask :push do
  # add the generate rake task first
  Rake::Task[:generate].invoke
  # code omitted
end
```</p>

<p>Additionally I want to know visually when a page is a draft.  For that I add "Draft: " to the title.</p>

<p>```html _includes/article.html
</p>

<h1>in the <header> tag</h1>

<p>{% if index %}
  # add {% if post.published == false %}Draft: {% endif %}
  <h1 class="entry-title"><a href="{{ root_url }}{{ post.url }}">{% if post.published == false %}Draft: {% endif %}{% if site.titlecase %}{{ post.title | titlecase }}{% else %}{{ post.title }}{% endif %}</a></h1>
{% else %}
  # add {% if page.published == false %}Draft: {% endif %}
  <h1 class="entry-title">{% if page.published == false %}Draft: {% endif %}{% if site.titlecase %}{{ page.title | titlecase }}{% else %}{{ page.title }}{% endif %}</h1>
{% endif %}

```</p>

<p>Now you will see "Draft: " in front of any unpublished posts.</p>

<h2>Manual management</h2>

<p>A few additional things I like to do, but I haven't automated yet are:</p>

<ol>
<li>Add "-draft" to the file name.</li>
<li>Change the publish date to the day I publish the article

<ol>
<li>This involves changing the file name as well as the front matter</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RBAC in Ruby]]></title>
    <link href="http://jkamenik.github.com/blog/2014/01/10/rbac-in-ruby/"/>
    <updated>2014-01-10T15:07:00-05:00</updated>
    <id>http://jkamenik.github.com/blog/2014/01/10/rbac-in-ruby</id>
    <content type="html"><![CDATA[<p>RBAC stands for <em>Role Based Access Control</em>.  It is basically a means to programmitically configure access rights without hardcoding.</p>

<p>The full details are <a href="http://en.wikipedia.org/wiki/Role-based_access_control">here</a>, but to be honest I don't fully understand it as writen.  What I understand of it is from trial and error.</p>

<p>This entry is an attempt to codify that understanding and apply it using the ruby language.</p>

<!-- more -->


<h2>Basics</h2>

<p>The inputs to the policy are:</p>

<ol>
<li>User or Actor</li>
<li>Action being performed</li>
<li>Resource being acted on</li>
</ol>


<pre>
    +-------------------------------------------------------+
    | +-------+                                +----------+ |
    | |       |            +------+            |          | |
    | |  User |+---------->|Action|+---------->| Resource | |
    | |       |            +------+            |          | |
    | +-------+                                +----------+ |
    +-------------------------------------------------------+
                               +
                               |
                               v
                            +------+
                            |Policy|
                            +------+
                               +
                               |
                               v
                          +---------+
                          |Yes or No|
                          +---------+
</pre>


<h2>Policy</h2>

<p>The policy is where the business logic goes.  It can be as simple as a set of Ruby classes that simply return values, or it can be as complicated as ActiveDirectory.</p>

<p>The players are:</p>

<ol>
<li>Role - collection of permissions bound to a user</li>
<li>Permission - an answer which is limited to a resource and action</li>
</ol>


<p>Here is the basic flow of a permission:</p>

<pre>
    +------+            +------+             +------------+
    | User |+---------->| Role |+----------->| Permission |
    +------+            +------+             |------------|
              Has many            Has many   | Resource   |
                                             | Action     |
                                             | Allowed?   |
                                             +------------+
</pre>


<p>A user can have 1 or more roles.  Each role can have 1 or more permissions.  Each permission associates an action on a resource with an answer.  Either the user is explicitly allowed or explicitly not allowed to access the Resource.</p>

<p><em>Note:</em> I have purposely kept the data model simple.  In more complicated setups there can be several levels of permissions, permissions can have filters, and/or permissions can be directly bound to a user (instead of being bound to a role).  These complications are often introduced to deal with edge cases which are outside the scope of this article.</p>

<h3>Policy logic sample code</h3>

<p>Once the actors are known the logic is easy.  Simply filter in only the permission on a user for the resource and action in question then "and" all permissions together.</p>

<p>```ruby
class Policy</p>

<pre><code># returns true if the user *can* perform action on resource, false otherwise
def allowed?(user,action,resource)
    reduce_permissions list_permissions(user,action,resource)
end
</code></pre>

<p>private</p>

<pre><code># returns an array of filtered permissions
def list_permissions(user,action,resource)
    perm = user.roles.inject([]) do |array,role|
        array.concat role.permissions.for(resource).with(action).compact
    end
end

def reduce_permissions(perm_array)
    return implicit_allow if perm_array.empty?

    perm_array.reduce(true,:&amp;&amp;)
end

# "and", for "or" use ":||"
def reduce_function
    :&amp;&amp;
end

# default behavior is NOT to give access
def implicit_allow
    false
end
</code></pre>

<p>end
```</p>
]]></content>
  </entry>
  
</feed>
